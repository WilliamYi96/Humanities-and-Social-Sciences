# ARM汇编语言的伪操作、宏指令和伪指令
ARM汇编语言源程序中语句一般由指令、伪操作、宏指令和伪指令构成。
其中，伪操作是指ARM汇编程序中的助记符，在源程序转变为汇编程序的时候被处理，而不是在计算机运行期间被程序执行；宏指令是一段独立的程序代码，通过伪操作进行定义，可以进行宏替换，其仅仅在调用时用宏体插入到源程序中；伪指令也是一种特殊的指令助记符，但是其不是在处理器运行期间由及其运行，而是在汇编时被转换为合适的机器指令替换为ARM或者Thumb指令，从而实现真正的指令操作。

## ADS编译环境下的伪操作和伪指令
相关内容属于手册的部分，因此需要时查阅相关手册即可。

## ARM伪指令
ARM伪指令是为了编程的方便而设计出来的一种指令，其可以在源程序进行汇编时将相关指令转变为等效的ARM指令。
ARM伪指令共有四条，分别为ADR伪指令、ADRL伪指令、LDR伪指令、NOP伪指令。

### ADR伪指令
通常，编译器通过一条ADD指令或者SUB指令来实现ADR伪指令的功能。若不能够用一条指令实现，则产生错误，编译失败。

其格式大致与ADD指令或者是SUB指令相同。

### ADRL伪指令
其与ADR最大的区别是ADRL有更大的地址读取能力。其他都是相似的。因此，一条ADRL指令可能需要多条SUB或者ADD指令才能完成。因为ARM指令的第二操作数的地址范围比ADRL取址范围小。

### LDR伪指令
LDR伪指令用于加载32位的立即数或者一个地址到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替代为一条合适的指令。若加载的常数未超出MOV或者MVN的范围，则使用MOV或者MVN指令代替该LDR伪指令，否则汇编器将常量放入文字池，并使用一条程序相对偏移的LDR指令从文字池中读出常量。
与ARM指令的LDR相比，伪指令的LDR的参数中有=号存在。

### NOP伪指令
NOP伪指令的重要功能是用于延时操作。其在汇编时被代替成ARM中的空操作。例如MOV R1,R1 等。

# ARM汇编语言程序设计
## ARM汇编中的文件格式
ARM程序源文件主要有三种格式，具体的情况说明如下：
![ARM源文件格式](http://img.blog.csdn.net/20170326152650496?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## ARM汇编语言语句格式
值得注意的是，ARM汇编语言中的最开头是符号，接着是指令|伪操作|伪指令，末尾处可以添加注释。

只要将任何指令放在开头，ARM汇编都会认为其为符号。

## ARM汇编语言程序格式
ARM汇编语言是以**段**为单位进行源文件组织的。
段又分为数据段和代码段。其中数据段至少要有一个，代码段可以有非负的若干整数。

在源程序经过汇编处理后生成一个可执行的映像文件。其包含三个部分的内容：
一个或者多个代码段，其通常是只读的；
零个或者多个包含初始值的数据段，这些数据段通常是可读写的；
零个或者多个不包含初始值的数据段，这些数据段通常也是可以读写的，值得注意的是，这类数据在经过编译之后只会在内存中保留地址，而不会被存储数据等其他信息。

## 嵌入式C语言程序设计技巧
### 变量定义
在变量声明的时候，为了节省空间的需要，最好把所有相同类型的变量放在一起定义，同时这样可以优化存储器布局。

同时，值得注意的是，对于局部变量类型的定义，使用short或者char来定义变量并不总是比int节省空间。由于ARM执行的是32位的运算，因此有时int类型的变量声明更加具有优势。

变量定义时，从精简程序的角度，程序眼总是竭力避免使用冗余变量。但是有时使用冗余变量可以减少存储器访问的次数，从而提高系统的性能。

### 参数传递
为了使C语言程序和汇编程序能够相互调用，因此定义了统一的函数过程调用标准ATPCS。ATPCS定义了寄存器组中的{R0-R3}作为参数传递和结果返回寄存器，如果参数数目超过4个，则要使用堆栈的方式进行函数或者参数的传递。

### 循环条件
不同的循环条件，通过汇编执行时，即使完成的是相同的任务，有时也会有不同的系统性能表现。
![循环条件](http://img.blog.csdn.net/20170326152721882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# C与汇编语言混合编程
## 寄存器的使用规则
在ATPCS标准之下，寄存器的使用遵循以下规则:
![寄存器使用规则](http://img.blog.csdn.net/20170326152745809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 数据栈的使用规则
ATPCS规定数据栈均为FD(满递减)类型，并且对数据栈的操作是8字节对其的。***此句话如何理解？***

## 参数的使用规则
当参数不超过4个时，可以使用寄存器R0-R3进行参数传递；当参数超过4个时，剩余参数使用数据栈来传递参数。入栈的顺序和参数顺序相反，即最后一个字数据先入栈。
(为何说此处是参数个数可变的参数传递)
***而之后的存在参数个数固定的子程序参数传递？？***

当结果为一个32位的整数时，可以通过寄存器R0返回；结果为一个64位整数时，可以通过寄存器R0和R1返回，因此类推。**那么如果是一个160位数呢？当然，如果可能的话**

## C和ARM汇编程序间相互调用
在C和ARM汇编程序之间的相互调用必须遵守ATPCS规则。
此注意相互调用主要有三个方面的内容：
1. 汇编程序对C全局变量的访问；
2. 在C语言程序中调用汇编程序；
3. 在汇编语言中调用C语言程序；

### 汇编程序对C全局变量的访问
可以通过使用IMPORT关键词在汇编语言中对全局变量的调用进行声明。

### 在C语言程序中调用汇编程序
一切胜在不言中：
![在C语言中调用汇编程序](http://img.blog.csdn.net/20170326152826294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 在汇编语言中调用C语言程序
需要在汇编语言调用该程序之前，在汇编语言程序中使用IMPORT伪操作来声明该C程序。同时，在汇编程序中通过BL指令来调用子程序。
![在汇编语言中调用C语言程序](http://img.blog.csdn.net/20170326152850587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
# 基于ADS环境的软件开发实例
详情根据实际内容进行ADS环境之下的软件开发。
![数据拷贝程序](http://img.blog.csdn.net/20170326152906513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsbGlhbXlpOTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
